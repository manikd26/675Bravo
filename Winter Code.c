#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  liftDeploy,     sensorDigitalOut)
#pragma config(Sensor, I2C_1,  rightFlywheel,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftFlywheel,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftBack,      tmotorVex393HighSpeed_HBridge, openLoop, reversed, driveLeft)
#pragma config(Motor,  port2,           leftFront,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           rightFront,    tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           intake,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           topRightLaunch, tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port6,           btmRightLaunch, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           btmLeftLaunch, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           topLeftLaunch, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           conveyor,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          rightBack,     tmotorVex393HighSpeed_HBridge, openLoop, reversed, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define flyEncLeft nMotorEncoder[topLeftLaunch]
#define flyEncRight nMotorEncoder[topRightLaunch]

#define intakeBtn vexRT(Btn7R)
#define intakeOutBtn vexRT(Btn7U)
#define conveyorBtn vexRT(Btn6U)
#define launcherBtn vexRT(Btn6D)


int driveThreshold = 20;

bool launcherOn = false;
bool lastLauncherBtn = false;


bool intakeOn = true;
bool lastIntakeBtn = false;

//RPM Calculation
float encCurrent;
float encLast;
float lastTime;
float deltaTime;
float deltaEnc;
float leftVelocity;
float rightVelocity;
float ticksPerRev = 392;
float launcherRatio = 9.8;

//PID Constants
float Kp = 0.025;
float Ki = 0;
float Kd = 0;
float KpL = Kp;
float KiL = Ki;
float KdL = Kd;
float KpR = Kp;
float KiR = Ki;
float KdR = Kd;

float rpmLeft;
float rpmRight;

float rpmHigh = 2000;
float rpmMid;
float rpmLow;
float leftError;
float rightError;
float lastErrorLeft;
float lastErrorRight;

float pLeft;
float pRight;
float intRawLeft;
float intRawRight;
float intLeft;
float intRight;
float dLeft;
float dRight;

float integralActiveZone = 0; //value of rpm after which proportion stops taking effect

float powerLeft = 60.0;
float powerRight = 60.0;

int index;

void leftFlywheelSpeed()
{
	//Current encoder value
	encCurrent = getMotorEncoder(topLeftLaunch);

	//Get change in time; reset time
	deltaTime = nSysTime - lastTime;
	lastTime = nSysTime;

	//Get change in ticks; reset last value
	deltaEnc = encCurrent - encLast;
	encLast = encCurrent;

	//Calculate final velocity
	leftVelocity = (deltaEnc/deltaTime)/1000 * 60 / ticksPerRev * 9.8;
}

void rightFlywheelSpeed()
{
	//Current encoder value
	encCurrent = getMotorEncoder(topRightLaunch);

	//Get change in time; reset time
	deltaTime = nSysTime - lastTime;
	lastTime = nSysTime;

	//Get change in ticks; reset last value
	deltaEnc = encCurrent - encLast;
	encLast = encCurrent;

	//Calculate final velocity
	//Conversion to RPM???
	rightVelocity = (deltaEnc/deltaTime)/1000 * 60 / ticksPerRev;
}

void setFlywheel(float left, float right)
{
	int l = round(left);
	int r = round(right);
	if(l < 0)
		l *=-1;
	if(r < 0)
		r *=-1;
	motor[btmLeftLaunch] = l;
	motor[topLeftLaunch] = l;
	motor[btmRightLaunch] = r;
	motor[topRightLaunch] = r;
}

void PIDlaunch(float target)
{
	float deltaTime = abs(nSysTime - lastTime);
	float rpmConversion = ((launcherRatio * 60000) / deltaTime) / ticksPerRev;
	rpmLeft = abs(flyEncLeft * rpmConversion);
	rpmRight = abs(flyEncRight * rpmConversion);


	leftError = target - rpmLeft;
	rightError = target - rpmRight;

	//Proportion
	pLeft = KpL*leftError;
	pRight = KpR*rightError;

	//Integral
	if (abs(leftError) < integralActiveZone && leftError != 0)
	{
		intRawLeft = intRawLeft + leftError;
	}
	else //if error is so big and P is still taking effect, raw = 0
	{
		intRawLeft = 0;
	}

	if (abs(rightError) < integralActiveZone && rightError != 0)
	{
		intRawRight = intRawRight + rightError;
	}
	else
	{
		intRawRight = 0;
	}

	intLeft = KiL * intRawLeft;
	intRight = KiR * intRawRight;


	//Derivative
	dLeft = KdL*(leftError - lastErrorLeft);
	dRight = KdR*(rightError - lastErrorRight);
	lastErrorLeft = leftError;
	lastErrorRight = rightError;

	if (leftError == 0)
	{
		dLeft = 0;
	}
	if (rightError == 0)
	{
		dRight = 0;
	}


	//Final Power
	powerLeft = pLeft + intLeft + dLeft; //should be P+I+D
	powerRight = pRight + intRight + dRight;

	lastErrorLeft = leftError;
	lastErrorRight = rightError;
	lastTime = nSysTime;

	wait1Msec(20);
}


task main()
{
	int motorValues[4]= {0, 80, 60, 40};
	index = 0;
	while(true)
	{
		//setFlywheel(powerLeft, powerRight);
		//PIDlaunch(rpmHigh);


		/**
		Launcher Toggle
		if(launcherBtn && !lastLauncherBtn) {
		launcherOn = !launcherOn;
		lastLauncherBtn = true;
		}
		if(launcherBtn == 0) {
		lastLauncherBtn = false;
		launcherOn = false;
		}
		**/
		if (!lastLauncherBtn && launcherBtn) {
			launcherOn = true;
			lastLauncherBtn = true;
		}
		if (launcherBtn && launcherOn){
			motor[topLeftLaunch] = motorValues[index];
			motor[btmLeftLaunch] = motorValues[index];
			motor[topRightLaunch] = motorValues[index];
			motor[btmRightLaunch] = motorValues[index];
			index++;
			if (index > 3) {
				index = 0;
				launcherOn = false;
				lastLauncherBtn = false;
			}
			wait1Msec(1000);
		}
		//Drive
		if(abs(vexRT(Ch3)) > driveThreshold)	{
			motor[leftFront] = vexRT(Ch3);
			motor[leftBack] = vexRT(Ch3);
			} else {
			motor[leftFront] = 0;
			motor[leftBack] = 0;
		}

		if(abs(vexRT(Ch2)) > driveThreshold)
		{
			motor[rightFront] = vexRT(Ch2);
			motor[rightBack] = vexRT(Ch2);
		}
		else
		{
			motor[rightFront] = 0;
			motor[rightBack] = 0;
		}

		//Conveyor
		if (conveyorBtn)
			motor[conveyor] = 127;
		else if (vexRT(Btn5U))
			motor[conveyor] = -127;
		else
			motor[conveyor] = 0;

		//Intake
		if (intakeBtn && !lastIntakeBtn)
		{
			intakeOn = !intakeOn;
			lastIntakeBtn = true;
		}
		if (intakeBtn == 0)
			lastIntakeBtn = false;

		if (intakeOutBtn == 1)
		{
			motor[intake] = -127;
		}
		else
		{
			motor[intake] = intakeOn * 127;
		}




	}

}
